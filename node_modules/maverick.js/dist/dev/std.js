export { DOMEvent, EventsTarget, appendTriggerEvent, attachDeclarativeShadowDOM, camelToKebabCase, camelToTitleCase, createComment, createFragment, findTriggerEvent, flattenArray, getOriginEvent, getSlottedChildren, hasTriggerEvent, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isKeyboardClick, isKeyboardEvent, isMouseEvent, isPointerEvent, isTouchEvent, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, listenEvent, lowercaseFirstLetter, run, runAll, setAttribute, setStyle, toggleClass, trimTrailingSemicolon, uppercaseFirstChar, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed } from './chunks/chunk-VABDA4SA.js';
import { onDispose } from './chunks/chunk-NQ7TQAU7.js';
export { createRegex, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, unwrap, unwrapDeep } from './chunks/chunk-NQ7TQAU7.js';

// src/std/aria.ts
function ariaBool(value) {
  return value ? "true" : "false";
}

// src/std/disposal.ts
function createDisposalBin() {
  const disposal = /* @__PURE__ */ new Set();
  return {
    add(...callbacks) {
      for (const callback of callbacks)
        disposal.add(callback);
    },
    empty() {
      for (const callback of disposal)
        callback();
      disposal.clear();
    }
  };
}
function useDisposalBin() {
  const disposal = createDisposalBin();
  onDispose(disposal.empty);
  return disposal;
}

// src/std/object.ts
function keysOf(obj) {
  return Object.keys(obj);
}
function mergeProperties(...sources) {
  const target = {};
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    }
  }
  return target;
}
function pick(source, props) {
  const target = {};
  for (const prop of props) {
    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
  }
  return target;
}
function omit(source, props) {
  return pick(
    source,
    keysOf(source).filter((key) => !props.includes(key))
  );
}

// src/std/promise.ts
function deferredPromise() {
  let resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function timedPromise(promise, timeout, timeoutMsg) {
  const timer = new Promise((_, reject) => {
    const timerId = setTimeout(() => {
      clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });
  return Promise.race([promise, timer]);
}

// src/std/timing.ts
function waitTimeout(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function waitAnimationFrame(callback) {
  return new Promise((resolve) => {
    window.requestAnimationFrame((time) => {
      callback?.(time);
      resolve();
    });
  });
}
function animationFrameThrottle(func) {
  let id = -1, lastArgs;
  function throttle(...args) {
    lastArgs = args;
    if (id >= 0)
      return;
    id = window.requestAnimationFrame(() => {
      func.apply(this, lastArgs);
      id = -1;
      lastArgs = void 0;
    });
  }
  return throttle;
}
var requestIdleCallback = "requestIdleCallback" in window ? window.requestIdleCallback : (cb) => window.requestAnimationFrame(cb);
function waitIdlePeriod(callback, options) {
  return new Promise((resolve) => {
    requestIdleCallback((deadline) => {
      callback?.(deadline);
      resolve();
    }, options);
  });
}

export { animationFrameThrottle, ariaBool, createDisposalBin, deferredPromise, keysOf, mergeProperties, omit, pick, timedPromise, useDisposalBin, waitAnimationFrame, waitIdlePeriod, waitTimeout };
