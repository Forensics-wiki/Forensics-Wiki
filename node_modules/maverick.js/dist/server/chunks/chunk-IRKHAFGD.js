import { createComment, DOMEvent, isDOMNode, createFragment, attachDeclarativeShadowDOM, setAttribute, toggleClass, setStyle, listenEvent, trimTrailingSemicolon, flattenArray } from './chunk-UQUIIFVF.js';
import { root, isFunction, isArray, isString, isNumber, noop, unwrapDeep, effect, isUndefined, peek, scoped, computed, provideContext, isNull, isBoolean } from './chunk-3GPUVQSV.js';
import { root as root$1, scoped as scoped$1, getScope, isFunction as isFunction$1, effect as effect$1, onDispose, signal } from '@maverick-js/signals';

// src/std/html.ts
function escape(value, isAttr = false) {
  const type = typeof value;
  if (type !== "string") {
    if (!isAttr && type === "function")
      return escape(value());
    if (isAttr && type === "boolean")
      return value + "";
    return value;
  }
  const delimeter = isAttr ? '"' : "<", escapeDelimeter = isAttr ? "&quot;" : "&lt;";
  let iDelimeter = value.indexOf(delimeter), isAmpersand = value.indexOf("&");
  if (iDelimeter < 0 && isAmpersand < 0)
    return value;
  let left = 0, out = "";
  while (iDelimeter >= 0 && isAmpersand >= 0) {
    if (iDelimeter < isAmpersand) {
      if (left < iDelimeter)
        out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } else {
      if (left < isAmpersand)
        out += value.substring(left, isAmpersand);
      out += "&amp;";
      left = isAmpersand + 1;
      isAmpersand = value.indexOf("&", left);
    }
  }
  if (iDelimeter >= 0) {
    do {
      if (left < iDelimeter)
        out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } while (iDelimeter >= 0);
  } else
    while (isAmpersand >= 0) {
      if (left < isAmpersand)
        out += value.substring(left, isAmpersand);
      out += "&amp;";
      left = isAmpersand + 1;
      isAmpersand = value.indexOf("&", left);
    }
  return left < value.length ? out + value.substring(left) : out;
}

// src/runtime/ssr/render.ts
function renderToString(root4) {
  const result = root((dispose) => {
    const value = root4();
    dispose();
    return value;
  });
  return { code: resolve(escape(result)) };
}
var SSR_TEMPLATE = /* @__PURE__ */ Symbol();
function resolve(node) {
  if (isFunction(node)) {
    return resolve(node());
  } else if (isArray(node)) {
    let result = "";
    const flattened = node.flat(10);
    for (let i = 0; i < flattened.length; i++) {
      result += resolve(escape(flattened[i]));
    }
    return result + "<!/[]>";
  } else if (isString(node) || isNumber(node)) {
    return node + "";
  } else if (node == null ? void 0 : node[SSR_TEMPLATE]) {
    return node[SSR_TEMPLATE];
  }
  return "";
}
function injectHTML(html) {
  return { [SSR_TEMPLATE]: html };
}

// src/element/controller.ts
var ComponentController = class {
  /**
   * The custom element this component is attached to. This is safe to use server-side with the
   * limited API listed below.
   *
   * **Important:** Only specific DOM APIs are safe to call server-side. This includes:
   *
   * - Attributes: `getAttribute`, `setAttribute`, `removeAttribute`, and `hasAttribute`
   * - Classes: `classList` API
   * - Styles: `style` API
   * - Events (noop): `addEventListener`, `removeEventListener`, and `dispatchEvent`
   */
  get el() {
    return this.instance._el;
  }
  /**
   * Reactive component properties.
   */
  get $props() {
    return this.instance._props;
  }
  /**
   * Reactive component store.
   */
  get $store() {
    return this.instance._store;
  }
  constructor(instance) {
    this.instance = instance;
    if (this.onAttach)
      instance._attachCallbacks.push(this.onAttach.bind(this));
    if (this.onConnect)
      instance._connectCallbacks.push(this.onConnect.bind(this));
    if (this.onDisconnect)
      instance._disconnectCallbacks.push(this.onDisconnect.bind(this));
    if (this.onDestroy)
      instance._destroyCallbacks.push(this.onDestroy.bind(this));
  }
  /**
   * This method can be used to specify attributes that should be set on the host element. Any
   * attributes that are assigned to a function will be considered a signal and updated accordingly.
   */
  setAttributes(attributes) {
    if (this.instance._attrs)
      Object.assign(this.instance._attrs, attributes);
  }
  /**
   * This method can be used to specify styles that should set be set on the host element. Any
   * styles that are assigned to a function will be considered a signal and updated accordingly.
   */
  setStyles(styles) {
    if (this.instance._styles)
      Object.assign(this.instance._styles, styles);
  }
  /**
   * This method is used to satisfy the CSS variables contract specified on the current
   * custom element definition. Other CSS variables can be set via the `setStyles` method.
   */
  setCSSVars(vars) {
    this.setStyles(vars);
  }
  /**
   * Type-safe utility for creating component DOM events.
   */
  createEvent(type, ...init) {
    return new DOMEvent(type, init[0]);
  }
  /**
   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to
   * match all component events.
   */
  dispatch(type, ...init) {
    return;
  }
  /**
   * Adds an event listener for the given `type` and returns a function which can be invoked to
   * remove the event listener.
   *
   * - The listener is removed if the current scope is disposed.
   * - This method is safe to use on the server (noop).
   */
  listen(type, handler, options) {
    return noop;
  }
};

// src/element/component.ts
var Component = class extends ComponentController {
  constructor(instance) {
    super(instance);
    if (this.render && !instance._innerHTML && !instance._renderer) {
      instance._renderer = this.render.bind(this);
    }
  }
  destroy() {
    this.instance._destroy();
  }
};

// src/runtime/dom/reconcile.ts
function reconcile(parent, nodesA, nodesB) {
  let lengthB = nodesB.length, endA = nodesA.length, endB = lengthB, startA = 0, startB = 0, after = nodesA[endA - 1].nextSibling, map = null;
  while (startA < endA || startB < endB) {
    if (nodesA[startA] === nodesB[startB]) {
      startA++;
      startB++;
      continue;
    }
    while (nodesA[endA - 1] === nodesB[endB - 1]) {
      endA--;
      endB--;
    }
    if (endA === startA) {
      const node = endB < lengthB ? startB ? nodesB[startB - 1].nextSibling : nodesB[endB - startB] : after;
      while (startB < endB)
        parent.insertBefore(nodesB[startB++], node);
    } else if (endB === startB) {
      while (startA < endA) {
        if (!map || !map.has(nodesA[startA]))
          nodesA[startA].remove();
        startA++;
      }
    } else if (nodesA[startA] === nodesB[endB - 1] && nodesB[startB] === nodesA[endA - 1]) {
      const node = nodesA[--endA].nextSibling;
      parent.insertBefore(nodesB[startB++], nodesA[startA++].nextSibling);
      parent.insertBefore(nodesB[--endB], node);
      nodesA[endA] = nodesB[endB];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = startB;
        while (i < endB)
          map.set(nodesB[i], i++);
      }
      const index = map.get(nodesA[startA]);
      if (index != null) {
        if (startB < index && index < endB) {
          let i = startA, sequence = 1, t;
          while (++i < endA && i < endB) {
            if ((t = map.get(nodesA[i])) == null || t !== index + sequence)
              break;
            sequence++;
          }
          if (sequence > index - startB) {
            const node = nodesA[startA];
            while (startB < index)
              parent.insertBefore(nodesB[startB++], node);
          } else
            parent.replaceChild(nodesB[startB++], nodesA[startA++]);
        } else
          startA++;
      } else
        nodesA[startA++].remove();
    }
  }
}

// src/runtime/dom/walker.ts
var createMarkerWalker = (root4) => (
  // @ts-expect-error - filter accepts `boolean` but not typed.
  document.createTreeWalker(root4, NodeFilter.SHOW_COMMENT, (node) => node.nodeValue === "$")
);

// src/runtime/dom/render.ts
var hydration = null;
function hydrate(root4, options) {
  return runHydration(() => render(root4, options), options);
}
function runHydration(run, options) {
  const prev = hydration;
  hydration = { w: createMarkerWalker(options.target) };
  const result = run();
  hydration = prev;
  return result;
}
function render(root4, options) {
  return root((dispose) => {
    if (!hydration) {
      insert(options.target, root4(), options.before);
    } else {
      unwrapDeep(root4);
    }
    return dispose;
  });
}

// src/runtime/dom/insert.ts
function insert(parent, value, marker) {
  let isSignal = isFunction(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction(value);
  }
  if (isSignal) {
    let current;
    effect(
      () => void (current = insertExpression(
        parent,
        unwrapDeep(value()),
        marker,
        current,
        true
      ))
    );
    return;
  } else if (hydration) {
    marker.remove();
  } else
    insertExpression(parent, value, marker);
}
function insertExpression(parent, value, marker, current, isSignal = false) {
  if (value === current)
    return current;
  if (isArray(value)) {
    const newNodes = [], currentNodes = hydration && marker ? claimArray(marker) : current && isArray(current) ? current : [];
    if (value.length && resolveArray(newNodes, value, currentNodes, isSignal)) {
      effect(() => void (current = insertExpression(parent, newNodes, marker, currentNodes, true)));
      return () => current;
    }
    if (hydration && marker)
      return currentNodes;
    if (newNodes.length === 0) {
      updateDOM(parent, current);
    } else if (currentNodes.length) {
      reconcile(parent, currentNodes, newNodes);
    } else {
      current && updateDOM(parent, current, marker);
      appendArray(parent, newNodes, marker);
    }
    return newNodes;
  } else if (isString(value) || isNumber(value)) {
    if (!isUndefined(marker)) {
      if (isDOMNode(current) && current.nodeType === 3) {
        current.data = value + "";
      } else if (!hydration) {
        return updateDOM(parent, current, marker, document.createTextNode(value + ""));
      } else {
        return marker.nextSibling;
      }
    } else if (current !== "" && isString(current)) {
      return parent.firstChild.data = value + "";
    } else
      return parent.textContent = value + "";
  } else if (isDOMNode(value)) {
    if (hydration) ; else if (marker || isArray(current)) {
      if (!isUndefined(marker))
        return current = updateDOM(parent, current, marker, value);
      updateDOM(parent, current, null, value);
    } else if (!current || !parent.firstChild) {
      parent.appendChild(value);
    } else
      parent.replaceChild(value, parent.firstChild);
    return value;
  } else {
    return updateDOM(parent, current, marker);
  }
  return current;
}
function appendArray(parent, nodes, marker) {
  if (isUndefined(marker)) {
    for (let i = 0; i < nodes.length; i++)
      parent.appendChild(nodes[i]);
  } else {
    for (let i = 0; i < nodes.length; i++)
      parent.insertBefore(nodes[i], marker);
  }
}
function resolveArray(nodes, values, current, computed2) {
  let value, prev, effect4 = false;
  for (let i = 0; i < values.length; i++) {
    value = values[i], prev = current[i];
    if (isDOMNode(value)) {
      nodes.push(value);
    } else if (isArray(value)) {
      effect4 = resolveArray(nodes, value, isArray(prev) ? prev : [], computed2) || effect4;
    } else if (isFunction(value)) {
      if (computed2) {
        value = value();
        effect4 = resolveArray(
          nodes,
          isArray(value) ? value : [value],
          isArray(prev) ? prev : [prev],
          true
        ) || effect4;
      } else {
        nodes.push(value);
        effect4 = true;
      }
    } else if (value || value === 0) {
      const text = value + "";
      if (prev && prev.nodeType === 3 && prev.data === text) {
        nodes.push(prev);
      } else {
        nodes.push(document.createTextNode(text));
      }
    }
  }
  return effect4;
}
var ARRAY_END_MARKER = "/[]";
function claimArray(marker) {
  let node = marker.nextSibling, nodes = [];
  while (node) {
    if (node.nodeType !== 8) {
      nodes.push(node);
    } else if (node.nodeValue === ARRAY_END_MARKER) {
      node.remove();
      break;
    }
    node = node.nextSibling;
  }
  return nodes;
}
function updateDOM(parent, current, marker, replace) {
  if (isUndefined(marker)) {
    parent.textContent = "";
    return;
  }
  const node = replace || createComment("~");
  if (isArray(current) && current.length) {
    let el, inserted = false, isParent = false;
    for (let i = current.length - 1; i >= 0; i--) {
      el = current[i];
      if (el !== node) {
        isParent = el.parentNode === parent;
        if (!inserted && !i)
          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else
          isParent && parent.removeChild(el);
      } else
        inserted = true;
    }
  } else if (isDOMNode(current)) {
    parent.replaceChild(node, current);
  } else {
    parent.insertBefore(node, marker);
  }
  return node;
}

// src/runtime/dom/insert-lite.ts
var CONNECTED = /* @__PURE__ */ Symbol(0);
var INSERT_MARKER_NODE = createComment("$$");
var END_MARKER = /* @__PURE__ */ Symbol(0);
var END_MARKER_NODE = /* @__PURE__ */ createComment("/$");
var ARRAY_END_MARKER_VALUE = "/[]";
function insertLite(parent, value, before) {
  let isSignal = isFunction(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction(value);
  }
  if (isSignal) {
    insertEffect(parent, value, before);
  } else if (!hydration && (value || value === 0)) {
    addChild(
      parent,
      isArray(value) ? resolveArray2(value) : isDOMNode(value) ? value : document.createTextNode(value + ""),
      before
    );
  }
}
function addChild(parent, node, before) {
  if (!node)
    return;
  if (before)
    parent.insertBefore(node, before);
  else
    parent.appendChild(node);
}
function insertEffect(parent, value, before) {
  const marker = before && before.nodeType === 8 ? before : INSERT_MARKER_NODE.cloneNode();
  if (marker !== before)
    addChild(parent, marker, before);
  effect(() => void insertExpression2(marker, unwrapDeep(value)));
}
function insertExpression2(start, value) {
  const end = start[END_MARKER];
  if (isArray(value)) {
    if (hydration) {
      start[END_MARKER] = findArrayEndMarker(start);
    } else {
      if (end)
        removeOldNodes(start, end);
      const fragment = resolveArray2(value);
      if (!fragment)
        return;
      if (!end)
        fragment.appendChild(createEndMarker(start));
      start.after(fragment);
    }
  } else if (isDOMNode(value)) {
    if (end)
      removeOldNodes(start, end);
    if (!hydration)
      start.after(value);
    if (!end)
      value.after(createEndMarker(start));
  } else if (isString(value) || isNumber(value)) {
    if (start[CONNECTED]) {
      start.nextSibling.data = value + "";
      return;
    }
    if (end)
      removeOldNodes(start, end);
    let text;
    if (!hydration) {
      text = document.createTextNode(value + "");
      start.after(text);
    } else {
      text = start.nextSibling;
    }
    start[CONNECTED] = true;
    if (!end)
      text.after(createEndMarker(start));
  } else if (end) {
    removeOldNodes(start, end);
  }
}
function createEndMarker(start) {
  return start[END_MARKER] = END_MARKER_NODE.cloneNode();
}
function findArrayEndMarker(node) {
  while (node) {
    if (node.nodeType === 8 && node.nodeValue === ARRAY_END_MARKER_VALUE)
      return node;
    node = node.nextSibling;
  }
}
function removeOldNodes(start, end) {
  while (start.nextSibling !== end)
    start.nextSibling.remove();
  start[CONNECTED] = false;
}
function resolveArray2(value) {
  const flattened = flattenArray(value);
  if (!flattened.length)
    return null;
  const fragment = createFragment();
  for (let i = 0; i < flattened.length; i++) {
    const child = flattened[i];
    if (isFunction(child)) {
      insertEffect(fragment, child);
    } else {
      fragment.append(child);
    }
  }
  return fragment;
}

// src/element/css.ts
var CSS = /* @__PURE__ */ Symbol();
var sheetCache = /* @__PURE__ */ new WeakMap();
var supported;
var supportsAdoptedStyleSheets = () => !isUndefined(supported) ? supported : supported = false;
function injectCSS(value) {
  return createCSS(value + "");
}
function css(strings, ...values) {
  let css2 = strings[0] ?? "";
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value == null ? void 0 : value[CSS]) {
      css2 += value.text;
    } else if (typeof value === "number") {
      css2 += value;
    } else ;
    css2 += strings[i + 1];
  }
  return createCSS(css2, strings);
}
function createCSS(css2, strings) {
  let styleSheet;
  return {
    [CSS]: true,
    get text() {
      return css2;
    },
    get sheet() {
      if (styleSheet) {
        return styleSheet;
      } else if (strings && sheetCache.has(strings)) {
        return sheetCache.get(strings);
      } else if (supportsAdoptedStyleSheets()) {
        (styleSheet = new CSSStyleSheet()).replaceSync(css2);
        if (strings)
          sheetCache.set(strings, styleSheet);
        return styleSheet;
      }
      return;
    },
    toString() {
      return css2;
    }
  };
}
function adoptCSS(root4, css2) {
  if (supportsAdoptedStyleSheets()) {
    root4.adoptedStyleSheets = css2.map((css3) => css3.sheet);
  } else {
    const style = document.createElement("style");
    style.textContent = css2.map((css3) => css3.text).join("");
    root4.appendChild(style);
  }
}

// src/element/register.ts
function registerCustomElement(Component2) {
  register(Component2);
}
function registerLiteCustomElement(Component2) {
  register(Component2);
}
function registerHeadlessCustomElement(Component2) {
  register(Component2);
}
var DOM_ELEMENT_REGISTRY = Symbol(0);
var serverElementRegistry = /* @__PURE__ */ new Map() ;
function register(Component2, init) {
  const tagName = Component2.el.tagName;
  {
    serverElementRegistry.set(tagName, Component2);
    return;
  }
}

// src/runtime/dom/internal.ts
function $$_create_template(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
var $$_create_fragment = createFragment;
function $$_create_walker(fragment, walker = ((_a2) => (_a2 = hydration) == null ? void 0 : _a2.w)()) {
  try {
    return [$$_next_element(walker), walker];
  } catch (e) {
    return $$_create_walker(fragment, createMarkerWalker(document.importNode(fragment, true)));
  }
}
function $$_next_template(fragment) {
  return $$_create_walker(fragment)[0];
}
function $$_next_element(walker) {
  let element = walker.nextNode().nextSibling;
  if (element.localName.indexOf("-") > 0 && element.firstChild && element.firstChild.nodeName === "SHADOW-ROOT") {
    let node = element.firstChild.nextSibling || element.nextSibling;
    if (node)
      walker.currentNode = node;
  }
  return element;
}
var $$_hydrating = hydration;
function $$_setup_custom_element(host, props) {
  var _a2;
  const Component2 = (_a2 = window[DOM_ELEMENT_REGISTRY]) == null ? void 0 : _a2.get(host.localName);
  if (!Component2) {
    throw Error(
      host.localName
    );
  }
  const component = createComponent(Component2, { props });
  host.attachComponent(component);
  return component.instance._scope;
}
function $$_clone(fragment) {
  const clone = document.importNode(fragment, true);
  return clone.firstElementChild;
}
function $$_create_element(tagName) {
  return document.createElement(tagName);
}
function $$_attach_declarative_shadow_dom(element) {
  var _a2;
  if (((_a2 = element.firstChild) == null ? void 0 : _a2.nodeName) === "TEMPLATE") {
    if (element.firstChild.hasAttribute("shadowroot")) {
      attachDeclarativeShadowDOM(element);
    } else {
      element.firstChild.remove();
    }
  }
}
var $$_insert = insert;
function $$_insert_at_marker(marker, value) {
  insert(marker.parentElement, value, marker);
}
var $$_insert_lite = insertLite;
function $$_insert_at_marker_lite(marker, value) {
  insertLite(marker.parentElement, value, marker);
}
function $$_create_component(component, props = {}) {
  return peek(() => component(props));
}
var $$CHILDREN = /* @__PURE__ */ Symbol(0);
function $$_children(fn) {
  fn[$$CHILDREN] = true;
  return fn;
}
function $$_ref(element, ref) {
  if (isArray(ref)) {
    ref.filter(isFunction).forEach((ref2) => ref2(element));
  } else if (isFunction(ref)) {
    ref(element);
  }
}
function $$_directive(element, directive, args) {
  if (isFunction(directive))
    directive(element, ...args);
}
var $$_attr = setAttribute;
var $$_class = toggleClass;
var $$_style = setStyle;
function $$_spread(element, props) {
  const keys = Object.keys(props);
  for (let i = 0; i < keys.length; i++) {
    const prop2 = keys[i];
    if (prop2 in element) {
      if (isFunction(props[prop2])) {
        effect(() => void (element[prop2] = props[prop2]()));
      } else {
        element[prop2] = props[prop2];
      }
    } else if (isFunction(props[prop2])) {
      effect(() => void $$_attr(element, prop2, props[prop2]()));
    } else {
      $$_attr(element, prop2, props[prop2]);
    }
  }
}
function $$_merge_props(...sources) {
  const target = sources[0] || {};
  for (let i = 1; i < sources.length; i++) {
    const source = sources[i];
    if (source)
      Object.assign(target, source);
  }
  return target;
}
function $$_listen(target, type, handler, capture = false) {
  if (isFunction(handler)) {
    listenEvent(target, type, handler, { capture });
  }
}
var DELEGATED_EVENTS = /* @__PURE__ */ Symbol(0);
function $$_delegate_events(types, document2 = window.document) {
  const events = document2[DELEGATED_EVENTS] ??= /* @__PURE__ */ new Set();
  for (let i = 0, len = types.length; i < len; i++) {
    const type = types[i];
    if (!events.has(type)) {
      events.add(type);
      document2.addEventListener(type, delegated_event_handler);
    }
  }
}
function delegated_event_handler(event) {
  const eventKey = `$$${event.type}`, dataKey = `$$${event.type}Data`;
  let node = event.composedPath && event.composedPath()[0] || event.target;
  if (event.target !== node) {
    Object.defineProperty(event, "target", {
      configurable: true,
      value: node
    });
  }
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  let handler, data;
  while (node) {
    handler = node[eventKey];
    if (handler && !node.disabled && isFunction(handler)) {
      data = node[dataKey];
      !isUndefined(data) ? handler.call(node, data, event) : handler.call(node, event);
    }
    node = node.parentNode || node.host;
  }
}
var $$_peek = peek;
var $$_scoped = scoped;
var $$_effect = effect;
var $$_computed = computed;
function hydrateLite(root4, options) {
  return runHydration(() => renderLite(root4, options), options);
}
function renderLite(root4, options) {
  return root$1((dispose) => {
    if (!hydration) {
      insertLite(options.target, root4());
    } else {
      unwrapDeep(root4);
    }
    return dispose;
  });
}
var PROPS = /* @__PURE__ */ Symbol(0);
var METHODS = /* @__PURE__ */ Symbol(0);
function createComponent(Component2, init) {
  const instance = new ComponentInstance(Component2, init);
  return scoped$1(() => new Component2(instance), instance._scope);
}
var ComponentInstance = class {
  constructor(Component2, init = {}) {
    this._el = null;
    this._renderer = null;
    this._innerHTML = false;
    this._destroyed = false;
    this._attrs = {};
    this._styles = {};
    this._props = {};
    // these props cause type issues - don't type them.
    this._state = null;
    this._store = null;
    this._attachCallbacks = [];
    this._connectCallbacks = [];
    this._disconnectCallbacks = [];
    this._destroyCallbacks = [];
    root$1((dispose) => {
      var _a2;
      this._scope = getScope();
      this._dispose = dispose;
      if (init.scope)
        init.scope.append(this._scope);
      const store = Component2.el.store;
      if (store) {
        this._store = store.create();
        this._state = new Proxy(this._store, {
          get: (_, prop2) => this._store[prop2]()
        });
        provideContext(store, this._store);
      }
      const props = Component2.el.props;
      if (props) {
        this._props = createInstanceProps(props);
        if (init.props) {
          for (const prop2 of Object.keys(init.props)) {
            if (prop2 in props) {
              const value = init.props[prop2];
              if (isFunction$1(value)) {
                effect$1(() => void this._props[prop2].set(value()));
              } else {
                this._props[prop2].set(value);
              }
            }
          }
        }
      }
      if ((_a2 = init.props) == null ? void 0 : _a2.innerHTML) {
        this._innerHTML = true;
      }
      onDispose(this._destroy.bind(this));
    });
  }
  _destroy() {
    var _a2;
    if (this._destroyed)
      return;
    this._destroyed = true;
    for (const destroy of this._destroyCallbacks) {
      scoped$1(() => destroy(this._el), this._scope);
    }
    (_a2 = this._el) == null ? void 0 : _a2.destroy();
    this._attachCallbacks.length = 0;
    this._connectCallbacks.length = 0;
    this._disconnectCallbacks.length = 0;
    this._destroyCallbacks.length = 0;
    this._dispose();
    this._el = null;
    this._renderer = null;
  }
};
function createInstanceProps(defs) {
  const props = {};
  for (const name of Object.keys(defs)) {
    const def = defs[name];
    props[name] = signal(def.value, def);
  }
  return props;
}

// src/element/create-html-element.ts
function createHTMLElement(Component2, init) {
  {
    throw Error(
      "[maverick] `createHTMLElement` was called outside of browser - use `createServerElement`"
    );
  }
}
var registry = /* @__PURE__ */ new Map();
function createServerElement(Component2) {
  if (registry.has(Component2))
    return registry.get(Component2);
  const register2 = Component2.register;
  if (Component2.register) {
    const result = isArray(register2) ? register2 : register2 == null ? void 0 : register2();
    if (isArray(result)) {
      for (const Component3 of result) {
        serverElementRegistry.set(Component3.el.tagName, Component3);
      }
    }
  }
  class MaverickElement extends ServerCustomElement {
    static get _component() {
      return Component2;
    }
  }
  registry.set(Component2, MaverickElement);
  return MaverickElement;
}
var ServerCustomElement = class {
  constructor() {
    this.keepAlive = false;
    this._component = null;
    this._rendered = false;
    this._attachCallbacks = /* @__PURE__ */ new Set();
    this.attributes = new Attributes();
    this.style = new Style();
    this.classList = new ClassList();
  }
  get component() {
    return this._component;
  }
  get $store() {
    var _a2;
    return (_a2 = this._component) == null ? void 0 : _a2.instance._store;
  }
  get state() {
    return {};
  }
  attachComponent(component) {
    scoped$1(() => {
      this.setAttribute("mk-h", "");
      this.setAttribute("mk-d", "");
      if (this.hasAttribute("class")) {
        parseClassAttr(this.classList.tokens, this.getAttribute("class"));
      }
      if (this.hasAttribute("style")) {
        parseStyleAttr(this.style.tokens, this.getAttribute("style"));
      }
      const instance = component.instance;
      instance._el = this;
      this._component = component;
      for (const callback of [...instance._attachCallbacks, ...this._attachCallbacks]) {
        callback(this);
      }
      this._attachCallbacks = null;
      const $attrs = instance._attrs, $styles = instance._styles;
      if ($attrs) {
        for (const name of Object.keys($attrs))
          setAttribute(this, name, unwrapDeep($attrs[name]));
      }
      if ($styles) {
        for (const name of Object.keys($styles))
          setStyle(this, name, unwrapDeep($styles[name]));
      }
      this._rendered = !!instance._renderer;
      this._ssr = instance._renderer ? renderToString(instance._renderer).code : "";
      if (this.classList.length > 0) {
        this.setAttribute("class", this.classList.toString());
      }
      if (this.style.length > 0) {
        this.setAttribute("style", this.style.toString());
      }
    }, component.instance._scope);
  }
  render() {
    if (typeof this._ssr !== "string") {
      throw Error("[maverick] called `render` before attaching component");
    }
    const innerHTML = this.renderInnerHTML(), def = this.constructor._component.el;
    return this._rendered || def.shadowRoot && def.css ? def.shadowRoot ? `<template shadowroot="${this.getShadowRootMode()}">${innerHTML}</template>` : `<shadow-root>${innerHTML}</shadow-root>` : innerHTML;
  }
  renderInnerHTML() {
    if (typeof this._ssr !== "string") {
      throw Error("[maverick] called `renderInnerHTML` before attaching component");
    }
    const def = this.constructor._component.el, styleTag = def.shadowRoot && def.css ? `<style>${def.css.map((css2) => css2.text).join("")}</style>` : "";
    return styleTag + this._ssr;
  }
  getShadowRootMode() {
    const def = this.constructor._component.el;
    return def.shadowRoot ? isBoolean(def.shadowRoot) ? "open" : def.shadowRoot.mode : "open";
  }
  getAttribute(name) {
    return this.attributes.getAttribute(name);
  }
  setAttribute(name, value) {
    this.attributes.setAttribute(name, value);
  }
  hasAttribute(name) {
    return this.attributes.hasAttribute(name);
  }
  removeAttribute(name) {
    return this.attributes.removeAttribute(name);
  }
  dispatchEvent() {
    return false;
  }
  onEventDispatch() {
  }
  addEventListener() {
  }
  removeEventListener() {
  }
  subscribe() {
    return noop;
  }
  onAttach(callback) {
    if (this._component) {
      callback(this);
      return noop;
    } else {
      this._attachCallbacks.add(callback);
      return () => {
        var _a2;
        return (_a2 = this._attachCallbacks) == null ? void 0 : _a2.delete(callback);
      };
    }
  }
  destroy() {
    var _a2;
    (_a2 = this._component) == null ? void 0 : _a2.destroy();
  }
};
var Attributes = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  getAttribute(name) {
    return this._tokens.get(name) ?? null;
  }
  hasAttribute(name) {
    return this._tokens.has(name);
  }
  setAttribute(name, value) {
    this._tokens.set(name, value + "");
  }
  removeAttribute(name) {
    this._tokens.delete(name);
  }
  toString() {
    if (this._tokens.size === 0)
      return "";
    let result = "";
    for (const [name, value] of this._tokens) {
      result += ` ${name}="${escape(value, true)}"`;
    }
    return result;
  }
};
var Style = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  getPropertyValue(prop2) {
    return this._tokens.get(prop2) ?? "";
  }
  setProperty(prop2, value) {
    this._tokens.set(prop2, value ?? "");
  }
  removeProperty(prop2) {
    const value = this._tokens.get(prop2);
    this._tokens.delete(prop2);
    return value ?? "";
  }
  toString() {
    if (this._tokens.size === 0)
      return "";
    let result = "";
    for (const [name, value] of this._tokens) {
      result += `${name}: ${value};`;
    }
    return result;
  }
};
var ClassList = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Set();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  add(...tokens) {
    for (const token of tokens) {
      this._tokens.add(token);
    }
  }
  contains(token) {
    return this._tokens.has(token);
  }
  remove(token) {
    this._tokens.delete(token);
  }
  replace(token, newToken) {
    if (!this._tokens.has(token))
      return false;
    this._tokens.delete(token);
    this._tokens.add(newToken);
    return true;
  }
  toggle(token, force) {
    if (force !== true && (this._tokens.has(token) || force === false)) {
      this._tokens.delete(token);
      return false;
    } else {
      this._tokens.add(token);
      return true;
    }
  }
  toString() {
    return Array.from(this._tokens).join(" ");
  }
};

// src/element/props.ts
var PROP_DEF = Symbol(0);
function defineProp(definition) {
  return { [PROP_DEF]: true, ...definition };
}

// src/element/define.ts
function defineElement(declaration) {
  var _a2;
  if ("props" in declaration) {
    const props = declaration.props;
    for (const name of Object.keys(props)) {
      const def = ((_a2 = props[name]) == null ? void 0 : _a2[PROP_DEF]) ? props[name] : { [PROP_DEF]: true, value: props[name] };
      if (def.attribute !== false && !def.type)
        def.type = inferAttributeType(def.value);
      props[name] = def;
    }
  }
  return declaration;
}
var STRING = {
  from: (v) => v === null ? "" : v + ""
};
var NUMBER = {
  from: (v) => v === null ? 0 : Number(v)
};
var BOOLEAN = {
  from: (v) => v !== null,
  to: (v) => v ? "" : null
};
var FUNCTION = {
  from: false,
  to: () => null
};
var ARRAY = {
  from: (v) => v === null ? [] : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
var OBJECT = {
  from: (v) => v === null ? {} : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
function inferAttributeType(value) {
  if (value === null)
    return STRING;
  switch (typeof value) {
    case "undefined":
      return STRING;
    case "string":
      return STRING;
    case "boolean":
      return BOOLEAN;
    case "number":
      return NUMBER;
    case "function":
      return FUNCTION;
    case "object":
      return isArray(value) ? ARRAY : OBJECT;
    default:
      return STRING;
  }
}

// src/element/decorators.ts
function prop(target, propertyKey, descriptor) {
  if (!target[PROPS])
    target[PROPS] = /* @__PURE__ */ new Set();
  target[PROPS].add(propertyKey);
}
function method(target, propertyKey, descriptor) {
  if (!target[METHODS])
    target[METHODS] = /* @__PURE__ */ new Set();
  target[METHODS].add(propertyKey);
}

// src/runtime/ssr/internal.ts
function $$_ssr(template, ...parts) {
  let result = "";
  for (let i = 0; i < template.length; i++) {
    result += template[i];
    result += resolve(escape(parts[i]));
  }
  return { [SSR_TEMPLATE]: result };
}
function $$_custom_element(tagName, props, spreads) {
  const Component2 = serverElementRegistry.get(tagName);
  if (!Component2) {
    throw Error(`[maverick] custom element not registered: ${tagName}`);
  }
  const host = new (createServerElement(Component2))();
  if (spreads && spreads.length > 0) {
    const spread = $$_merge_spreads(spreads);
    for (const [key, value] of spread.attributes) {
      host.setAttribute(key, value);
    }
    for (const token of spread.classList) {
      host.classList.add(token);
    }
    for (const [key, value] of spread.styles) {
      host.style.setProperty(key, value);
    }
  }
  const component = createComponent(Component2, { props });
  host.attachComponent(component);
  const children = !(props == null ? void 0 : props.innerHTML) && (props == null ? void 0 : props.$children) ? scoped(() => props.$children(), component.instance._scope) : [];
  return [
    host.attributes + ">",
    injectHTML(!(props == null ? void 0 : props.innerHTML) ? host.render() : props.innerHTML),
    ...children
  ];
}
function $$_attr2(name, value) {
  const attrValue = resolveAtrr(value);
  return isString(attrValue) ? ` ${name}="${escape(attrValue, true)}"` : "";
}
function resolveAtrr(value) {
  if (isFunction(value))
    return resolveAtrr(value());
  if (!value && value !== "" && value !== 0) {
    return null;
  } else {
    return value + "";
  }
}
function $$_classes(base, tokens) {
  let baseValue = unwrapDeep(base), result = isString(baseValue) ? baseValue : "";
  if (tokens && Object.keys(tokens).length > 0) {
    const classList = /* @__PURE__ */ new Set();
    parseClassAttr(classList, result);
    resolveClasses(classList, tokens);
    result = Array.from(classList).join(" ");
  }
  result = result.trim();
  return result.length ? ` class="${escape(result, true)}"` : "";
}
var classSplitRE = /\s+/;
function parseClassAttr(tokens, attrValue) {
  const classes = attrValue.trim().split(classSplitRE);
  for (const token of classes)
    tokens.add(token);
}
function resolveClasses(classList, tokens) {
  for (const name of Object.keys(tokens)) {
    if (unwrapDeep(tokens[name])) {
      classList.add(name);
    } else {
      classList.delete(name);
    }
  }
}
function $$_styles(base, tokens) {
  let baseValue = unwrapDeep(base), result = isString(baseValue) ? trimTrailingSemicolon(baseValue) : "";
  if (Object.keys(tokens).length > 0) {
    const styleMap = /* @__PURE__ */ new Map();
    parseStyleAttr(styleMap, result);
    resolveStyles(styleMap, tokens);
    result = "";
    for (const [name, value] of styleMap)
      result += `${name}: ${value};`;
  }
  result = result.trim();
  return result.length ? ` style="${escape(result, true)}"` : result;
}
var styleSplitRE = /\s*:\s*/;
var stylesDelimeterRE = /\s*;\s*/;
function parseStyleAttr(tokens, attrValue) {
  const styles = attrValue.trim().split(stylesDelimeterRE);
  for (let i = 0; i < styles.length; i++) {
    if (styles[i] === "")
      continue;
    const [name, value] = styles[i].split(styleSplitRE);
    tokens.set(name, value);
  }
}
function resolveStyles(tokens, styles) {
  for (const name of Object.keys(styles)) {
    const value = unwrapDeep(styles[name]);
    if (!value && value !== 0) {
      tokens.delete(name);
    } else {
      tokens.set(name, value + "");
    }
  }
}
var propNameRE = /[A-Z]/;
function $$_merge_spreads(spreads) {
  let attributes = /* @__PURE__ */ new Map(), classList = /* @__PURE__ */ new Set(), styles = /* @__PURE__ */ new Map();
  for (let i = 0; i < spreads.length; i++) {
    const { $$class, $$style, class: classBase, style: styleBase, ...attrs } = spreads[i];
    const attrNames = Object.keys(attrs);
    for (let j = 0; j < attrNames.length; j++) {
      const attrName = attrNames[j];
      if (!propNameRE.test(attrName)) {
        const attrValue = resolveAtrr(attrs[attrName]);
        if (isString(attrValue)) {
          attributes.set(attrName, attrValue);
        } else {
          attributes.delete(attrName);
        }
      }
    }
    if ("class" in spreads[i]) {
      const base = unwrapDeep(classBase);
      if (isNull(base) || base === false) {
        classList.clear();
      } else if (isString(base) && base.length) {
        parseClassAttr(classList, base + "");
      }
    }
    if ($$class)
      resolveClasses(classList, $$class);
    if ("style" in spreads[i]) {
      const base = unwrapDeep(styleBase);
      if (isNull(base) || base === false) {
        styles.clear();
      } else if (isString(base) && base.length) {
        parseStyleAttr(styles, base);
      }
    }
    if ($$style)
      resolveStyles(styles, $$style);
  }
  return { attributes, classList, styles };
}
function $$_spread2(spreads) {
  const { attributes, classList, styles } = $$_merge_spreads(spreads);
  let result = "";
  if (classList.size > 0) {
    let _class = Array.from(classList).join(" ");
    result += `class="${escape(_class.trim(), true)}"`;
  }
  for (const [name, value] of attributes) {
    result += ` ${name}="${escape(value, true)}"`;
  }
  if (styles.size > 0) {
    let _styles = "";
    for (const [name, value] of styles)
      _styles += `${name}: ${value};`;
    result += ` style="${escape(_styles.trim(), true)}"`;
  }
  return result.trim();
}
function $$_inject_html(value) {
  return injectHTML(resolve(value));
}
var $$_scoped2 = scoped;
/**
 * The code below this comment was adapted from Lit: https://github.dev/lit/lit
 *
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

export { $$CHILDREN, $$_attach_declarative_shadow_dom, $$_attr2 as $$_attr, $$_attr as $$_attr2, $$_children, $$_class, $$_classes, $$_clone, $$_computed, $$_create_component, $$_create_element, $$_create_fragment, $$_create_template, $$_create_walker, $$_custom_element, $$_delegate_events, $$_directive, $$_effect, $$_hydrating, $$_inject_html, $$_insert, $$_insert_at_marker, $$_insert_at_marker_lite, $$_insert_lite, $$_listen, $$_merge_props, $$_merge_spreads, $$_next_element, $$_next_template, $$_peek, $$_ref, $$_scoped2 as $$_scoped, $$_scoped as $$_scoped2, $$_setup_custom_element, $$_spread2 as $$_spread, $$_spread as $$_spread2, $$_ssr, $$_style, $$_styles, ARRAY, BOOLEAN, Component, ComponentController, ComponentInstance, FUNCTION, NUMBER, OBJECT, PROP_DEF, SSR_TEMPLATE, STRING, adoptCSS, createComponent, createHTMLElement, createServerElement, css, defineElement, defineProp, hydrate, hydrateLite, hydration, inferAttributeType, injectCSS, injectHTML, method, parseClassAttr, parseStyleAttr, prop, registerCustomElement, registerHeadlessCustomElement, registerLiteCustomElement, render, renderLite, renderToString, resolve, runHydration };
